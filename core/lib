#!/bin/bash
# (C) 2013-2019 David 'Mokon' Bond, All Rights Reserved

if [[ "$SHELL" != *bash* && ! -z $PS1 ]] ; then
  SHELLS=($(chsh -l |grep bash)) ;
  if [ -z "${SHELLS[0]}" ] ; then
    if groups ${USER}|grep -q wheelx ; then
      if type dnf > /dev/null ; then
        sudo dnf -y install bash
      elif type yum > /dev/null ; then
        sudo yum -y install bash
      elif type apt-get > /dev/null ; then
        sudo apt-get -y install bash
      fi
    else
      echo "your shell is not bash and you are not in the wheel group"
      echo "please ask the system administrator to install bash"
    fi
  fi

  chsh -s ${SHELLS[0]}
  echo "your shell has been changed to bash, please re-run menv"
  exit -1
fi
. ~/menv/core/directories
export menv_user=dbond

# A tag to use to specify menv created the item in question
export menv_gen_tag="menv_generated"

# Absolute paths for lsb commands.
export BINMV=/bin/mv
export BINCP=/bin/cp
if [ $DIST != "darwin" ] ; then
  export $BINMV_BCK="$BINMV --backup=numbered"
  export $BINCP_BCK="$BINCP --backup=numbered"
else
  export $BINMV_BCK="$BINMV"
  export $BINCP_BCK="$BINCP"
fi
export BINLN=/bin/ln
export BINRM=/bin/rm
export BINTAR=/bin/tar
export BINMKDIR=/bin/mkdir

# Some files on the local machine
export menv_local_login=$menv_local_dir/login
export menv_local_nonlogin=$menv_local_dir/nonlogin
export menv_local_logout=$menv_local_dir/logout
export menv_target_handler=$menv_core_dir/target_handler

# Some dotfile names
export bashrc=.bashrc
export bash_profile=.bash_profile
export bash_logout=.bash_logout

alias menv_install="source ${menv_core_dir}/install"
alias menv_uninstall="source ${menv_core_dir}/uninstall"
alias menv_update="source ${menv_core_dir}/update"

# Load menv_config
if [ -f $menv_local_dir/menv_config ]; then
  source $menv_local_dir/menv_config
elif [ -f $menv_core_dir/menv_config ]; then
  source $menv_core_dir/menv_config
fi

# Silent pushd and popd
function spushd {
  pushd $@ &> /dev/null
}

function spopd {
  popd $@ &> /dev/null
}

# executes a target
function menv_target {
  local file=$1

  source $menv_targets_dir/$file
}

# Executes all the target.d children.
function menv_target_children {
  local file=$1
  local files=$(find $menv_targets_dir/${file}.d \
    -type f -and -not -name .gitkeep | sort )

  if [ ! -z "$files" ] ; then
    for f in $files ; do
      if [[ ! -z $MENV_MODULE_EXCLUDES && $f =~ $MENV_MODULE_EXCLUDES ]] ; then
        echo "Excluding $file module $f."
      else
        spushd .
        # TODO header with optional execution of code, darwin, desktop, gnome
        source $f
        spopd
      fi
    done
  fi
}

# Aux function to wget a file. If the second param is set then this is the name
# of the produced file.
function fetch {
  local url=$1

  command -v wget >/dev/null 2>&1 || { echo >&2 "wget not found" ; return ; }
  if [ -n "$2" ] ; then
    local fname=$2
  else
    local fname=`basename ${url}`
  fi
  echo "Fetching $url";
  wget -O $fname -q -N --timeout=10 --tries=3 --no-check-certificate ${url}
}

function fetch_w_timeout {
  local url=$1
  local timeout=${3:-60}

  command -v wget >/dev/null 2>&1 || { echo >&2 "wget not found" ; return ; }
  if [ -n "$2" ] ; then
    local fname=$2
  else
    local fname=`basename ${url}`
  fi
  echo "Fetching $url";
  timeout -k 5 $timeout wget -O $fname -q -N --no-check-certificate ${url}
}

# An aux function to grab a git repo
function github_fetch {
  local repo=$1

  fetch https://github.com/$repo/archive/master.tar.gz

  tar -xzf master.tar.gz
  $BINRM -f master.tar.gz
  $BINMV "$(basename $repo)-master" $(basename $repo)
}

# Aux function to setup a symbolic link. Backing up w/e was there before.
function safe_symlink {
  local file=$1
  local to=$2

  if [ -f $file ] && { [ ! -L $file ] || [`readlink $file` != "$to"] ; } ; then
    if ! diff -q $file /etc/skel/$file &> /dev/null ; then
      echo "Found foreign ${file}. Backing up as ${menv_backup_dir}/${file}."
      $BINMKDIR -p `dirname ${menv_backup_dir}/${file}`
      $BINMV_BCK $file ${menv_backup_dir}/${file}
    else
      # Found valid $file which is in the skel folder. Removing
      $BINRM $file
    fi
  elif [ -L $file ] ; then
    echo "Found valid $file symlink to ${to}."
  fi

  if [ ! -f $file ] ; then
    $BINLN -s $to $file
  fi
}

# A function to delete something if it is a symlink.
function if_symlink_rm {
  local file=$1

  if [ -L $file ] ; then
    $BINRM -f $file
  fi
}

# A nasty little function which grabs the latest sha hash from github
function menv_latest_version {
  local j=`curl -m 1 -L --connect-timeout 1 -s https://api.github.com/repos/mokon/menv/git/refs/heads/master | \
    sed 's/\\\\\//\//g' | sed 's/[{}]//g' | \
    awk -v k="text" '{n=split($0,a,","); for (i=1; i<=n; i++) print a[i]}' | \
    sed 's/\"\:\"/\|/g' | sed 's/[\,]/ /g' | sed 's/\"//g' | grep -w sha`
  local version=`echo ${j##*|} | awk {'print $2'}`
  if [ -z "$version" ] ; then
    version="unknown"
  fi
  echo $version
}

# Shows the menv version or sets if set is the op.
function menv_version {
  op=$1

  case $op in
    ignore) echo ignore &> ${menv_cache_dir}/version ;;
    set) menv_latest_version &> ${menv_cache_dir}/version ;;
    get|*) cat ${menv_cache_dir}/version ;;
  esac
}

function version_compare {
  if [[ $1 == $2 ]] ; then
    return 0
  fi
  local IFS=.
  local i ver1=($1) ver2=($2)
  for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)) ;  do
    ver1[i]=0
  done
  for ((i=0; i<${#ver1[@]}; i++)) ;  do
    if [[ -z ${ver2[i]} ]] ; then
      ver2[i]=0
    fi
    if ((10#${ver1[i]} > 10#${ver2[i]})) ; then
      return 1
    fi
    if ((10#${ver1[i]} < 10#${ver2[i]})) ; then
      return 2
    fi
  done
  return 0
}

function version_le {
  version_compare $1 $2
  case $? in
    1)
      return 1 ;;
    0|2)
      return 0 ;;
  esac
}

function version_ge {
  version_compare $1 $2
  case $? in
    2)
      return 1 ;;
    0|1)
      return 0 ;;
  esac
}

function append_crontab {
  local cmd=$1
  (crontab -l ; echo "$cmd") 2>&1 | grep -v "no crontab" | sort | uniq | crontab -
}

function delete_crontab {
  local cmd=$1
  crontab -l |sed "/$cmd/d" |grep -v 'no crontab' | sort | uniq | crontab -
}

function menv_lock {
  local lockfile=$1

  trap "/bin/rm -f $lockfile; exit" INT TERM EXIT

  if type lockfile &> /dev/null ; then
    lockfile -r-1 $lockfile
  else
    while true ; do
      if mkdir $lockfile; then
        break
      fi
    done
  fi
}

function menv_unlock {
  local lockfile=$1

  $BINRM -rf $lockfile
  trap - INT TERM EXIT
}

function delete_line_in_file {
    local pattern=$1
    local file=$2

    sed -i "/$pattern/d" $file
}

function testconnection {
  local server=$1
  local suc_msg=$2
  local err_msg=$3
  local dns_err_msg=$4

  host -W1 "$server" &> /dev/null
  if [ $? -ne 0 ]; then
    echo $dns_err_msg
    return 1
  else
    ping -c1 -W1 "$server" &> /dev/null
    if [ $? -ne 0 ]; then
      echo $err_msg
      return 1
    else
      echo $suc_msg
      return 0
    fi
  fi
}

function menv_load_install_opts {
  if [ ! -f $menv_install_opts_file ]; then
    export MENV_DESKTOP=0
  elif grep -v --quiet nodesktop $menv_install_opts_file ; then
    export MENV_DESKTOP=1
  else
    export MENV_DESKTOP=0
  fi

  if [ ! -f $menv_install_opts_file ]; then
    export MENV_DESKTOP=0
  elif grep -v --quiet noroot $menv_install_opts_file ; then
    export MENV_ROOT=1
  else
    export MENV_ROOT=0
  fi
}

source $menv_core_dir/dist
